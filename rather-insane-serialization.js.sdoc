Rather insane serialization | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Rather Insane Serialization serves two purposes. One is to provide a reasonably
complete serialization/deserialization function that knows what to do with
non-JSON data types, circular references, and other such things. The other is to
provide a more compact format than JSON, especially for stuff like numerical
data.

(function () {

Serialization bytecode.
The first incarnation of this system used Javascript code as the serialization
format. So the deserializer simply evaluated the serialized data and returned
the result. This, of course, had several problems. First, it was insecure and
unnecessarily slow. Second, it required a full Javascript parser and interpreter
to deserialize stuff. Finally, it produced serialized data that was much larger
than theoretically necessary.

This version fixes those problems by using a compression-aware bytecode format.
The idea here is similar to the original format in that the serialized data is a
stream of commands to reconstruct the original, but distinct in that the
interpreter can be implemented relatively easily in any language.

All characters in the generated bytecode are printable, and by default the
serializer inserts linebreaks every 72 characters (though these linebreaks, as
well as any other whitespace, are ignored by the deserializer).

Constant table.
The bytecode is designed for compactness, so it contains a lot of arithmetic
coding. In particular, integers are encoded in base -94 and floating point
numbers are encoded in base 94 with two base-94 characters allocated for the
exponent and sign. All encodings are big-endian.

Booleans, null, and undefined are encoded as the constants with indices 0, 1, 2,
and 3, respectively. They aren't actually serialized in the constant table, but
the bytecode can refer to these values.

Strings are escape-encoded and are prefixed by their length. This means that 84
characters map directly to themselves, and there are ten escape prefixes. The
first two escape prefixes each take one following base-94 character, thus
encoding a combined entropy of 188. This two-byte escape is used for character
codes between 0 and 255 inclusive (remember that we don't need to worry about 84
of those characters).

Unicode characters are encoded as three-byte escapes; there are eight prefixes
followed by two base-94 characters. (This has a total entropy of 70688, which is
sufficient to encode the 65280 remaining possibilities.)

The two-byte escape prefixes are ! and ", and the three-byte escape prefixes are
#, $, %, &, ', (, ), and *. This leaves a contiguous range of ASCII characters
between 43 and 126 inclusive; these are all encoded verbatim.

String encoding is also used for regular expressions. The only difference here
is that there are several different regexp prefixes, one to encode each
configuration of flags.

Dates are encoded in milliseconds since the epoch, which requires 7 base-94
characters. There is only one date prefix.

Functions are encoded as strings but have different prefixes. Their properties
are referenced from the reference section, where they are treated as objects.

In addition to literal constants, the constant table encodes the number of
arrays and objects that exist. These are then referenced and made into a graph
in the reference section.

Reference section.
This section forms a graph from the objects in the constant table. It consists
of a series of base-94 numbers, each one wide enough to address any constant.
These numbers form a series of edge descriptions. Each edge description looks
like this:

| <object index> <number of edges> <edge> <edge> ... <edge>

If <object index> refers to an array, then each edge is just an index into the
constant table. Otherwise, each edge is a pair of constant table indexes; the
first is a string to encode the slot, and the second is the value that the slot
refers to. (So, for example, {foo: 'bar'} would have one edge whose slot index
points to the string 'foo' and whose value index points to the string 'bar'.)
