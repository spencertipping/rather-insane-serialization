Rather insane serialization | Spencer Tipping
Licensed under the terms of the MIT source code license


Introduction.
Rather Insane Serialization serves two purposes. One is to provide a reasonably
complete serialization/deserialization function that knows what to do with
non-JSON data types, circular references, class hierarchies, and other such
things. The other is to provide a more compact format than JSON, especially for
stuff like numerical data. Here is the general usage pattern:

| rather_insane_serialization().encode(value) -> string
  rather_insane_serialization().decode(string) -> value

The serialization output consists entirely of serializable characters and
newlines, and the newlines can be mangled or deleted without affecting the
deserialized data.


Stream state.
rather_insane_serialization() is a function because it supports class hierarchy
serialization. The use case is like this:

| var f = function () {};
  var sender = rather_insane_serialization();   // create a new stream
  var x = sender.encode(new f());
  var y = sender.encode(new f());
  var receiver = rather_insane_serialization();
  var xd = receiver.decode(x);
  var yd = receiver.decode(y);
  x.constructor === y.constructor       // -> true

We want to preserve the intensionality of classes, so we need to actually have
the classes deserialize to the same thing (and share a constructor table).

The internals behind this kind of thing are voodoo and black magic. In
particular, they involve rewriting the constructor such that constructors are
lost from their surrounding context:

| var f = function () {};
  var sender = rather_insane_serialization();
  sender.decode(sender.encode(new f())).constructor === f       // -> false

However, you can access the proxy constructor by asking for it, and in fact this
constructor is stable under serialization:

| var fd = sender.resolve(f);
  sender.decode(sender.encode(new f())).constructor === fd      // -> true
  sender.decode(sender.encode(new fd())).constructor === fd     // -> true


Serialization bytecode.
The first incarnation of this system used Javascript code as the serialization
format. So the deserializer simply evaluated the serialized data and returned
the result. This, of course, had several problems. First, it was insecure and
unnecessarily slow. Second, it required a full Javascript parser and interpreter
to deserialize stuff. Finally, it produced serialized data that was much larger
than theoretically necessary.

This version fixes those problems by using a compression-aware bytecode format.
The idea here is similar to the original format in that the serialized data is a
stream of commands to reconstruct the original, but distinct in that the
interpreter can be implemented relatively easily in any language.

All characters in the generated bytecode are printable, and by default the
serializer inserts linebreaks every 72 characters (though these linebreaks, as
well as any other whitespace, are ignored by the deserializer).

Generated bytecode has a uniform format: First a constant table, and then a
graph of references that connects the constants together.


Constant table.
The constant table begins with two four-byte numbers. The first indicates how many
constants it contains, and the second indicates which constant is the
serialization result. These numbers are followed by constants, described below.
A reference graph follows the constant table and specifies relationships between
objects.

The bytecode is designed for compactness, so it contains a lot of arithmetic
coding. In particular, integers are encoded in base 94 and floating point
numbers are encoded in base 94 with two base-94 characters allocated for the
exponent and the mantissa and exponent signs. All encodings are big-endian.

The first few entries of the constant table are fixed and are not serialized.
They are:

| 0: false              5: +infinity
  1: true               6: -infinity
  2: null               7: empty string
  3: undefined          8: 0
  4: NaN

Numbers have several different prefixes depending on the amount of information
required to encode them. Integers are coded with a letter describing both the
sign and the number of base-94 digits that are required to fully encode the
value. The largest integer possible in Javascript is 53 bits plus one bit for
the sign, and each base-94 digit encodes 6.55 bits of entropy, so an integer
will require between one and nine characters. Thus there are 18 prefixes for
integers: abcdefghi (for positive one to nine byte encodings, respectively), and
ABCDEFGHI (for negative one to nine byte encodings). Zero is encoded as the
digit '0'.

Floating point numbers are more straightforward to encode because two base-94
bytes (an entropy of 8836) is enough information to encode the exponent (entropy
of 308), exponent sign (entropy of 2), and mantissa sign (entropy of 2). The
remaining entropy of 7.17 is used to encode the number of bytes used to
represent the mantissa -- because the mantissa contains up to 53 bits, the
seven values map to 1, 2, 3, 4, 5, 7, and 9 bytes. The prefix for floating-point
numbers is 'j'.

Strings are escape-encoded and are prefixed by their length. This means that 84
characters map directly to themselves, and there are ten escape prefixes. The
first two escape prefixes each take one following base-94 character, thus
encoding a combined entropy of 188. This two-byte escape is used for character
codes between 0 and 255 inclusive (remember that we don't need to worry about 84
of those characters). The prefix for strings is '$'.

Unicode characters are encoded as three-byte escapes; there are eight prefixes
followed by two base-94 characters. (This has a total entropy of 70688, which is
sufficient to encode the 65280 remaining possibilities.)

The two-byte escape prefixes are ! and ", and the three-byte escape prefixes are
#, $, %, &, ', (, ), and *. This leaves a contiguous range of ASCII characters
between 43 and 126 inclusive; these are all encoded verbatim.

There are some special cases when encoding strings. Most strings that end up in
the constant table are actually quite short, so there are a bunch of prefixes
for strings that are small. They begin at the character K and continue until `,
which directly precedes 'a'. K denotes a string of length 1; the zero-length
string is implicitly present in the constant table.

String encoding is also used for regular expressions. The only difference here
is that there are several different regexp prefixes, one to encode each
configuration of flags. The prefixes and flag combinations are:

| r: /foo/      v: /foo/g
  s: /foo/i     w: /foo/gi
  t: /foo/m     x: /foo/gm
  u: /foo/mi    y: /foo/gmi

Nonstandard flags such as the 'y' in Firefox 3 are not serialized.

Dates are encoded in milliseconds since the epoch, which requires 7 base-94
characters. There is only one date prefix, 'J'.

Functions are encoded as strings but have different prefixes. Their properties
are referenced from the reference section, where they are treated as objects for
the purposes of edge connections (see 'Reference section' below). The function
prefix is '#'.

Some functions are used as constructors; these are modified at deserialization
time to make them safe to invoke. Not all functions need this modification,
though. Functions that are known constructors use the '@' prefix instead of '#'.

Arrays are encoded as the single character !. Their children are described in
the reference graph, since arrays can have circular references.

Regular objects (that is, those without a custom .constructor property) are
encoded by the single character ". If an object has a custom .constructor
property, it is encoded as a % followed by four bytes identifying the
constant-table index of its constructor function. This deserializer knows to
modify the constructor function in such a way that it can be safely invoked to
recreate the object. (The object's other properties are stored in the reference
graph.)

In addition to literal constants, the constant table encodes the number of
arrays and objects that exist. These are then referenced and made into a graph
in the reference section.


Reference section.
This section forms a graph from the objects in the constant table. It consists
first of a four-byte number to indicate how many objects are included, and then
a series of base-94 numbers, each one wide enough to address any constant. These
numbers form a series of edge descriptions. Each edge description looks like
this:

| <object index> <number of edges> <edge> <edge> ... <edge>

Each edge is a pair of constant table indexes; the first is a string or integer
to encode the slot, and the second is the value that the slot refers to. (So,
for example, {foo: 'bar'} would have one edge whose slot index points to the
string 'foo' and whose value index points to the string 'bar'.) The number of
edges is always four bytes wide.


Radix entropy coder.
Usage: radix_code(10)                   // -> '+'
       radix_code('+')                  // -> 10

var radix_encode = function (n, length) {
  // This function can return empty strings. To prevent this, pass in a value
  // for 'length'; the resulting number will be padded out to at least this many
  // characters.
  //
  // Note that 'n' must be positive for this function to work correctly.

  for (var digits = []; n; n = Math.floor(n / 94))
    digits.unshift(String.fromCharCode(33 + n % 94));

  while (length && digits.length < length)
    digits.unshift('!');

  return digits.join('');
};

var radix_decode = function (digits) {
  // Force floating point calculations in case integer overflow doesn't work
  // properly.
  for (var n = 0, base = 1.0,
           i = digits.length - 1; i >= 0; base *= 94, --i)
    n += (digits.charCodeAt(i) - 33) * base;
  return n;
};

var radix_code = function (x) {
  return x.constructor === String ? radix_decode(x) :
                                    radix_encode(x);
};

var radix_entropy = function (n) {
  return Math.floor(Math.log(n) / Math.log(94)) + 1;
};


Escape entropy coder.
Usage: escape_encode('string')          // -> 'escaped'
       escape_decode('escaped')         // -> 'string'

var escape_encode = function (s) {
  // Most characters pass through normally. Escape characters are handled by a
  // specialized radix coder. The ASCII passthrough range is 43 - 126
  // (inclusive); characters 33 - 42 are escape characters.

  for (var result = [],
           i = 0, l = s.length; i < l; ++i) {
    var c = s.charCodeAt(i);

    // Literal case: inside the passthrough range.
    if (c >= 43 && c <= 126) result.push(s.charAt(i));
    else

    // Two byte escape case: between 0 and 42. In this case we prepend the
    // escape character and radix-code c into base 94.
    if (c <= 42) result.push('!' + String.fromCharCode(33 + c));
    else

    // Two byte escape case: still prefixed with !, but not in the low range. In
    // this case we add 43, since that entropy has already been used.
    if (c <= 126 + 84 - 43) result.push('!' + String.fromCharCode(33 + c - 126 + 43));
    else

    // Two byte escape case: prefixed with ", so subtract 94 from the coded
    // number. (This follows because we're in base 94.)
    if (c <= 255) result.push('"' + String.fromCharCode(33 + c - 126 + 43 - 94));
    else

    // Three byte escape case: we can radix-code c, but we need to bump the
    // first character by two positions (since the zero and one slots are
    // already filled by ! and "). To do this we simply add 2 * 94 * 94 to c.
    result.push(radix_code(2 * 94 * 94 + c));
  }

  return result.join('');
};

var escape_decode = function (s) {
  for (var result = [],
           i = 0, l = s.length; i < l; ++i) {
    var c = s.charCodeAt(i);

    // Invalid character: just skip these.
    if (c <= 32 || c >= 127) continue;
    else

    // Two-byte escape case: radix-decode and handle the break in the piecewise
    // function. (See the various two-byte escape cases in the encoder for
    // insight into why we need this.)
    if (c <= 34) {
      var n = radix_code(s.charAt(i) + s.charAt(++i));
      if (n > 43) n += 126 - 43;
      result.push(String.fromCharCode(n));
    }
    else

    // Three-byte escape case: radix-decode and subtract 2 * 94 * 94.
    if (c <= 42) result.push(String.fromCharCode(-2 * 94 * 94 +
                                                 radix_code(s.charAt(i) +
                                                            s.charAt(++i) +
                                                            s.charAt(++i))));
    else

    // Regular case: append the character verbatim.
    result.push(s.charAt(i));
  }

  return result.join('');
};


Integer encoding.
This is just a radix encoding with a length/sign prefix.

var integer_encode = function (n) {
  var digits = radix_code(Math.abs(n));
  var prefix = String.fromCharCode(n ? n > 0 ? 97 + digits.length :
                                               65 + digits.length : 48);
  return prefix + digits;
};

var integer_decode = function (s, i) {
  var negative = s.charCodeAt(i) & 32;
  var length   = s.charAt(i).toUpperCase().charCodeAt(0) - 65;
  var n        = radix_code(s.substr(i + 1, length));
  return [n, length + 1];
};


Date encoding.
This is just a fixed-width radix encoding of the number of milliseconds since
the epoch.

var date_encode = function (d) {
  return 'J' + radix_encode(+d, 7);
};

var date_decode = function (s, i) {
  return [new Date(radix_decode(s.substr(i + 1, 7))), 8];
};


String encoding.
This is just escape encoding, except that the length and a '$' string prefix are
both prepended to the result. For short strings, the K to ` characters are used
to imply the length.

Note that this function shouldn't be used to encode the empty string (not that
anything bad will happen). The empty string is implicitly present in the
constant table, so it doesn't need to be added.

var string_encode = function (s) {
  var escaped = escape_encode(s);

  if (escaped.length <= 22)
    return String.fromCharCode(74 + escaped.length) + escaped;

  var length_prefix = radix_encode(escaped.length, 5);
  return '$' + length_prefix + escaped;
};

var string_decode = function (s, i) {
  if (s.charAt(i) === '$') {
    // Length-prefixed string (fully coded length in the first five bytes)
    var length = radix_code(s.substr(i + 1, 5));
    var string = escape_decode(s.substr(i + 6, length));
    return [string, length + 6];
  } else {
    // Length is encoded in the prefix
    var length = s.charCodeAt(i) - 74;
    var string = escape_decode(s.substr(i + 1, length));
    return [string, length + 1];
  }
};


Regular expression encoding.
This is just like string encoding, but the prefix varies depending on the flags.
There are also fewer digits used to encode the length, since regexps top out at
30M characters or so (and that's on Chrome, which has the highest tolerance for
this kind of thing). This means that we need only four digits.

var regexp_encode = function (r) {
  var multiples     = {g: 4, m: 2, i: 1};
  var parsed        = /^\/(.*)\/([gim]*)$/.exec(r.toString());
  var escaped       = escape_encode(parsed[1]);
  var length_prefix = radix_encode(escaped.length, 4);

  for (var flags = 0, flag_string = parsed[2],
           i = 0, l = flag_string.length; i < l; ++i)
    flags += multiples[flag_string.charAt(i)];

  return String.fromCharCode(114 + flags) + length_prefix + escaped;
};

var regexp_decode = function (s, i) {
  var flag_mask = s.charCodeAt(i) - 114;
  var flags     = [flag_mask & 1 ? 'i' : '',
                   flag_mask & 2 ? 'm' : '',
                   flag_mask & 4 ? 'g' : ''].join('');
  var length    = radix_code(s.substr(i + 1, 4));
  var content   = escape_decode(s.substr(i + 5, length));

  return [new RegExp(content, flags), length + 5];
};


Function encoding.
This is similar to string encoding, except that the word 'function' is trimmed
off of the front. This saves space in the encoded output. Also, only four
characters are used to represent the length.

Function encoding is subject to some subtle and tragic flaws. First, closure
state isn't preserved (nor can it be, as far as I'm aware). This means that
functions will lose their lexical closure variables -- invoking functions that
depend on these will result in ReferenceErrors.

More immediately, though, there's a problem with the Function constructor.
Specifically, it takes a variable number of arguments depending on how many
arguments the function expects; that is:

| function (x, y) {return x + y}
  // -> new Function('x', 'y', 'return x + y')

There's a trivial way around this problem; we just need to eval() some code in
the decoder; however, this means that the decoder is no longer secure, and
ensuring that the code it's evaluating isn't malicious becomes parse-complete.

More devious, but ultimately a better solution, is to still use the Function
constructor but modify the function body to include new logic to handle incoming
variables. For any function that takes arguments, these two definitions are
equivalent:

| function (x, y) {...}
  function () {var x = arguments[0]; var y = arguments[1]; ...}

There are only two cases where this is untrue. First, the .length property of
the function will differ; I can't think of a good way around this. Second, V8
and other statically-optimizing Javascript compilers will generate suboptimal
machine code for the function since its list of formals is empty.

In practice neither of these should matter a whole lot. I mean, you get to
serialize functions. How awesome is that?

var function_encode = function (f) {
  var code          = f.toString().replace(/^\s*function(\s*\w+)?/, '');
  var escaped       = escape_encode(code);
  var length_prefix = radix_encode(escaped.length, 4);

  return '#' + length_prefix + escaped;
};

var function_decode = function (s, i) {
  var length  = radix_code(s.substr(i + 1, 4));
  var code    = escape_decode(s.substr(i + 5, length));
  var pieces  = /^\s*\(([^\)]*)\)\s*\{([\s\S]*)\}\s*$/.exec(code);
  var formals = pieces[1].split(/\s*,\s*/);

  for (var variables = [],
           i = 0, l = formals.length; i < l; ++i)
    if (formals[i])
      variables.push(formals[i] + '=arguments[' + i + ']');

  var body = (variables.length ? 'var ' + variables.join(',') + ';' : '') +
             pieces[2];

  return [new Function(body), length + 5];
};


Floating-point encoding.
This is a fun one. It uses some ad-hoc floating-point manipulation code and a
tuple entropy coder to pack lots of data into the first two bytes of the
serialization.

You can only encode valid floating-point numbers, which conspicuously don't
include infinity, negative infinity, or NaN. It also doesn't handle 0, which has
its own encoding.

var float_encode = function (x) {
  // First determine the mantissa sign and flip it if necessary.
  var negative = x !== (x = Math.abs(x));

  // Next grab the floating-point exponent. To do this, we normalize the
  // mantissa to represent a 53-bit integer whose highest bit is always set.
  var log_2    = Math.log(2);
  var exponent = Math.floor(Math.log(x) / log_2) - 53;
  var mantissa = x / Math.exp(exponent * log_2) - Math.exp(53 * log_2);

  // We sometimes lose a few bits due to rounding error.
  if (mantissa < 0) mantissa = 0;

  // Now radix-code the mantissa, and always use 8 bytes to represent it.
  var encoded_mantissa = radix_encode(Math.round(mantissa), 8);

  // Radix-code the exponent, exponent sign, and mantissa sign.
  var exponent_negative = exponent !== (exponent = Math.abs(exponent));
  var encoded_exponent  = radix_encode(+negative + +exponent_negative * 2 +
                                       exponent * 4, 2);

  return 'j' + encoded_exponent + encoded_mantissa;
};

var float_decode = function (s, i) {
  var log_2          = Math.log(2);
  var exponent_block = radix_code(s.substr(i + 1, 2));
  var mantissa_block = radix_code(s.substr(i + 3, 8)) + Math.exp(53 * log_2);

  var exponent = (exponent_block >>> 2) * (exponent_block & 2 ? -1 : 1);

  return [mantissa_block * Math.exp(exponent * log_2) *
                           (exponent_block & 1 ? -1 : 1),
          11];
};


Array encoding.
This is straightforward; each array is exactly one character.

var array_encode = function (o)    {return '!'};
var array_decode = function (s, i) {return [[], 1]};


Object encoding.
This encoder is used for regular objects; don't use it for objects with custom
prototypes. (Since custom-prototype objects reference the constant table,
they're handled directly in the encode() and decode() functions.)

var object_encode = function (o)    {return '"'};
var object_decode = function (s, i) {return [{}, 1]};


Constructor encoding.
This is just like function encoding, but produces a function that is safe to
execute under certain conditions. The exact condition is that its first argument
is the secret key used to serialize the data structure.

There is no encoder because functions are marked as constructors retroactively.

var constructor_decode = function (s, i, key) {
  var length  = radix_code(s.substr(i + 1, 4));
  var code    = escape_decode(s.substr(i + 5, length));
  var pieces  = /^\s*\(([^\)]*)\)\s*\{([\s\S]*)\}\s*$/.exec(code);
  var formals = pieces[1].split(/\s*,\s*/);

  for (var variables = [],
           i = 0, l = formals.length; i < l; ++i)
    if (formals[i])
      variables.push(formals[i] + '=arguments[' + i + ']');

  var quoted_key      = '"' + key.replace(/["\\]/g, '\\$1') + '"';
  var early_return    = 'if (arguments[0] === ' + quoted_key + ') return;';

  var body = early_return +
             (variables.length ? 'var ' + variables.join(',') + ';' : '') +
             pieces[2];

  return [new Function(body), length + 5];
};


Instance encoding.
This is an object with a known constructor. Encoding and decoding each require
more information than usual; the decoder must verify that the constructor
function is in fact a valid constructor, and the encoder needs the index of the
constructor property in the constant table. Instances use the % prefix and are
followed by a four-byte constant table index.

var instance_encode = function (o, index) {
  return '%' + radix_encode(index, 4);
};

var instance_decode = function (s, i, constants, encoded_constants, key) {
  var index = radix_decode(s.substr(i + 1, 4));

  // Check the encoded constant table to make sure that the function at that
  // index begins with a '@' rather than a '#' (or anything else, for that
  // matter).
  if (encoded_constants[index] &&
      encoded_constants[index].charAt(0) === '@')
    return [new constants[index](key), 5];

  throw new Error('serialized value appears corrupt: referenced ' +
                  encoded_constants[index] + ' as a constructor function');
};


Object graph encoding and decoding.
These functions mark objects using a 'secret key' -- that is, a constant string
that is astronomically unlikely to exist in an object already. (The odds are
equivalent to guessing a 128-bit encryption key.)

Working with instances is surprisingly subtle. Most of it has to do with the way
prototypes work; the problem arises when prototype inheritance is used:

| var f = function () {...};
  var g = function () {...};
  g.prototype = new f();        // Set up superclass relationship
  g.prototype.constructor = g;  // Set up constructor (this is the problem)

Once the child class's constructor is reset, we have no way of accessing the
parent class.

The only workaround that I've come up with is to use 'instanceof' and topsort
the parents. So if functions F, G, and H are related with prototype inheritance
such that F is the superclass of G, which is the superclass of H, then
'instanceof' fully orders them by subclassing; that is:

| f.prototype instanceof Object         // probably true
  g.prototype instanceof f              // definitely true
  h.prototype instanceof g              // definitely true

Then we can identify a prototype by finding the most specific class that it's an
instance of; we can then encode the prototype as an instance of this class and
encode its .constructor property as just another attribute.

var encode = function (x) {
  // Generate a secret key that is used to identify boxed objects. Each
  // character is base-94, so it provides 6.5 bits of entropy. This means that
  // we need a total of 20 to get 128 bits.
  for (var key = '',
           i = 0; i < 20; ++i)
    key += String.fromCharCode((Math.random() * 95 >>> 0) + 33);

  // Model of the constant table and indexes; these are built during the
  // traversal phase.
  var strings   = {};
  var constants = [false, true, null, void 0, '' / '', 1 / 0, -1 / 0, '', 0];

  var graph  = {};
  var marked = [];

  // Create a graph link. This uses indirect identifiers.
  var link = function (object, property, value) {
    var converted_property = /^\d+$/.test(property) ? +property : property;

    var id = visit(object);
    graph[id] || (graph[id] = []);
    graph[id].push([visit(converted_property), visit(value)]);
    return object;
  };

  // Visit each of the fields in an object-like thing. This is used for anything
  // that is likely to have a box.
  var visit_fields = function (o) {
    for (var k in o)
      if (Object.hasOwnProperty.call(o, k) && k !== key)
        link(o, k, o[k]);
    return o;
  };

  // Recursively explore objects, identifying each one. The visit() function
  // returns the constant table ID of a value; for objects and arrays, it
  // prefixes the code with 'o' or 'a', respectively, to indicate that the ID
  // will change.
  var visit = function (o) {
    if (o === null)   return 2;
    if (o === void 0) return 3;

    if (o.constructor === Boolean)
      return +o;

    if (o.constructor === Number)
      if (o === 0)                  return 8;
      else if (o === Math.floor(o)) return constants.push(integer_encode(o)) - 1;
      else if (isNaN(o))            return 4;
      else if (! isFinite(o))       return 5 + +(o < 0);
      else                          return constants.push(float_encode(o)) - 1;

    if (o.constructor === String)
      if (o.length)
        // Update the string table so that we reuse strings when possible. Prefix
        // the index with the secret key to bypass any IE-related prototype bugs.
        return strings[key + o] ||
               (strings[key + o] = constants.push(string_encode(o)) - 1);
      else
        return 7;       // Offset of the empty string

    return mark(o);
  };

  // Adds an object to the constant table and traverses its children.
  var mark = function (o) {
    // No need to revisit an object we've already seen. I'm doing the
    // hasOwnProperty check here because we mark prototypes; if the prototype of
    // an object is marked, then it will appear to have a key even when it
    // doesn't really.
    if (Object.prototype.hasOwnProperty.call(o, key)) return o[key];

    marked.push(o);

    // Create the constant table entry. This has to happen first because
    // visiting an object's fields might re-enter this function and disrupt any
    // space we might have allocated.
    var use = function (encoder) {
      return o[key] = constants.push(encoder(o)) - 1;
    };

    // Use various encoders for the different kinds of objects.
    if (o.constructor === Object)        use(object_encode);
    else if (o.constructor === Array)    use(array_encode);
    else if (o.constructor === Date)     use(date_encode);
    else if (o.constructor === RegExp)   use(regexp_encode);
    else if (o.constructor === Function) use(function_encode);

    else {
      // We have a custom object type, so we need to encode its constructor.
      // Whether or not a given function is a constructor is determined by its
      // invocation, so here we just visit the regular function and then change
      // its marking to be a constructor.

      if (o.constructor === null || o.constructor === void 0)
        // Ok, this is really bad. Nobody should define a class hierarchy this
        // way. If this is the case, then we don't have a great way to get to
        // the constructor of an object (keep in mind that aside from the
        // .constructor property, there generally isn't another way to go from
        // the prototype to its owner function). I'm going to throw an error to
        // indicate that the class hierarchy is misleading; for some
        // applications there are probably better solutions.

        throw new Error('non-primitive object has no constructor: ' + o);

      // Mark the instance ahead of time to eliminate the vulnerability to
      // cycles. The constructor must appear before any of its instances.
      var ctor_index = o.constructor[key];

      if (! ctor_index) {
        marked.push(o.constructor);
        ctor_index = o.constructor[key] =
                     constants.push(function_encode(o.constructor)) - 1;
        o.constructor[key] = ctor_index;
        o[key] = constants.push(instance_encode(o, ctor_index)) - 1;

        visit_fields(o.constructor);
      }

      else o[key] = constants.push(instance_encode(o, ctor_index)) - 1;

      // Mark the function as being a constructor. Also be sure to visit its
      // prototype.
      if (constants[ctor_index].charAt(0) === '#') {
        constants[ctor_index] = '@' + constants[ctor_index].substr(1);
        link(o.constructor, 'prototype', o.constructor.prototype);
      }
    }

    visit_fields(o);

    return o[key];
  };

  // Visit the object that we want to serialize. This will side-effectfully
  // populate the constant table and the reference graph.
  var id = visit(x);

  // Unmark all of the objects we annotated. Because the key couldn't have
  // collided in the first place, we know it's ok to just delete it.
  for (var i = 0, l = marked.length; i < l; ++i)
    delete marked[i][key];

  // Serialize the reference graph. The first entry here is the length, which is
  // incremented for every object we serialize. As per the spec, all integer
  // serializations are adjusted to contain just enough entropy to encode any
  // constant.
  var constant_width = radix_entropy(constants.length - 1);
  var reference_graph = [0];
  for (var k in graph)
    if (Object.hasOwnProperty.call(graph, k)) {
      var edges = graph[k];

      ++reference_graph[0];
      reference_graph.push(radix_encode(+k, constant_width));
      reference_graph.push(radix_encode(edges.length, constant_width));

      for (var i = 0, l = edges.length; i < l; ++i) {
        reference_graph.push(radix_encode(edges[i][0], constant_width));
        reference_graph.push(radix_encode(edges[i][1], constant_width));
      }
    }

  reference_graph[0] = radix_encode(reference_graph[0], 4);

  // And that's all! We now have the complete constant table and the complete
  // reference graph, so we just serialize each one and put them back to back.
  return radix_encode(constants.length - 9, 4) +
         radix_encode(id, 4) +
         constants.slice(9).join('') +
         reference_graph.join('');
};

var decode = function (s) {
  // Create a new secret key for secure instantiation. See constructor_decode()
  // for more information.
  for (var key = '',
           i = 0; i < 20; ++i)
    key += String.fromCharCode((Math.random() * 95 >>> 0) + 33);

  // Decodes something based on the prefix and returns it, along with the number
  // of characters that should be skipped.
  var decode_one = function (s, i) {
    var prefix      = s.charAt(i);
    var prefix_code = prefix.charCodeAt(0);

    if (prefix === '!')               return array_decode(s, i);
    else if (prefix === '"')          return object_decode(s, i);
    else if (prefix === 'j')          return float_decode(s, i);
    else if (prefix === 'J')          return date_decode(s, i);
    else if (/[r-y]/.test(prefix))    return regexp_decode(s, i);
    else if (/[a-iA-I]/.test(prefix)) return integer_decode(s, i);

    else if (prefix === '$' ||
             prefix_code >= 74 &&
             prefix_code <= 96)       return string_decode(s, i);

    else if (prefix === '#')          return function_decode(s, i);
    else if (prefix === '@')          return constructor_decode(s, i, key);
    else if (prefix === '%')          return instance_decode(s, i,
                                                             constants,
                                                             encoded_constants,
                                                             key);
    else throw new Error('invalid prefix: ' + prefix);
  };

  // Remove all invalid characters from the original string.
  for (var valid = [],
           i = 0, l = s.length; i < l; ++i)
    if (s.charCodeAt(i) >= 33 && s.charCodeAt(i) <= 126)
      valid.push(s.charAt(i));

  s = valid.join('');

  // Reconstruct the constant table.
  var encoded_constants = ['', '', '', '', '', '', '', '', ''];

  var constants = [false, true, null, void 0, '' / '', 1 / 0, -1 / 0, '', 0];
  var result_id = radix_decode(s.substr(4, 4));

  for (var position = 8,
           i = radix_decode(s.substr(0, 4)) - 1; i >= 0; --i) {
    var parsed = decode_one(s, position);
    encoded_constants.push(s.substring(position, position += parsed[1]));
    constants.push(parsed[0]);
  }

  // Reconstruct the constant width. This is used for all of the entries in the
  // reference table.
  var w = radix_entropy(constants.length - 1);

  // We don't actually need to rebuild the reference graph as a structure.
  // Instead, we can just connect the edges as we decode them.
  for (var i = radix_decode(s.substring(position, position += 4)) - 1;
           i >= 0; --i) {
    var base = constants[radix_decode(s.substring(position,
                                                  position += w))];

    // Deserialize object groups, each one of which has one or many links.
    for (var j = radix_decode(s.substring(position, position += w)) - 1;
             j >= 0; --j) {
      var property = constants[radix_decode(s.substring(position,
                                                        position += w))];
      var value    = constants[radix_decode(s.substring(position,
                                                        position += w))];
      base[property] = value;
    }
  }

  return constants[result_id];
};
