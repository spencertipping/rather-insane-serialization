Introduction.
Rather Insane Serialization serves two purposes. One is to provide a reasonably
complete serialization/deserialization function that knows what to do with
non-JSON data types, circular references, class hierarchies, and other such
things. The other is to provide a more compact format than JSON, especially for
stuff like numerical data. Here is the general usage pattern:

| rather_insane_serialization().encode(value) -> string
  rather_insane_serialization().decode(string) -> value

The serialization output consists entirely of serializable characters and
newlines, and the newlines can be mangled or deleted without affecting the
deserialized data.


Stream state.
rather_insane_serialization() is a function because it supports class hierarchy
serialization. The use case is like this:

| var f = function () {};
  var sender = rather_insane_serialization();   // create a new stream
  var x = sender.encode(new f());
  var y = sender.encode(new f());
  var receiver = rather_insane_serialization();
  var xd = receiver.decode(x);
  var yd = receiver.decode(y);
  x.constructor === y.constructor       // -> true

We want to preserve the intensionality of classes, so we need to actually have
the classes deserialize to the same thing (and share a constructor table).

The internals behind this kind of thing are voodoo and black magic. In
particular, they involve rewriting the constructor such that constructors are
lost from their surrounding context:

| var f = function () {};
  var sender = rather_insane_serialization();
  sender.decode(sender.encode(new f())).constructor === f       // -> false

However, you can access the proxy constructor by asking for it, and in fact this
constructor is stable under serialization:

| var fd = sender.resolve(f);
  sender.decode(sender.encode(new f())).constructor === fd      // -> true
  sender.decode(sender.encode(new fd())).constructor === fd     // -> true

Note that a stateful serialization stream maintains a reference to every
constructor (and by extension, every prototype) that it ever sees. You'll need
to release references to the stream in order for the constructors to be
garbage-collected.


Serialization bytecode.
The first incarnation of this system used Javascript code as the serialization
format. So the deserializer simply evaluated the serialized data and returned
the result. This, of course, had several problems. First, it was insecure and
unnecessarily slow. Second, it required a full Javascript parser and interpreter
to deserialize stuff. Finally, it produced serialized data that was much larger
than theoretically necessary.

This version fixes those problems by using a compression-aware bytecode format.
The idea here is similar to the original format in that the serialized data is a
stream of commands to reconstruct the original, but distinct in that the
interpreter can be implemented relatively easily in any language.

All characters in the generated bytecode are printable, and by default the
serializer inserts linebreaks every 72 characters (though these linebreaks, as
well as any other whitespace, are ignored by the deserializer).

Generated bytecode has a uniform format: First a constant table, and then a
graph of references that connects the constants together.


Constant table.
The constant table begins with two four-byte numbers. The first indicates how many
constants it contains, and the second indicates which constant is the
serialization result. These numbers are followed by constants, described below.
A reference graph follows the constant table and specifies relationships between
objects.

The bytecode is designed for compactness, so it contains a lot of arithmetic
coding. In particular, integers are encoded in base 94 and floating point
numbers are encoded in base 94 with two base-94 characters allocated for the
exponent and the mantissa and exponent signs. All encodings are big-endian.

The first few entries of the constant table are fixed and are not serialized.
They are:

| 0: false              5: +infinity
  1: true               6: -infinity
  2: null               7: empty string
  3: undefined          8: 0
  4: NaN

Numbers have several different prefixes depending on the amount of information
required to encode them. Integers are coded with a letter describing both the
sign and the number of base-94 digits that are required to fully encode the
value. The largest integer possible in Javascript is 53 bits plus one bit for
the sign, and each base-94 digit encodes 6.55 bits of entropy, so an integer
will require between one and nine characters. Thus there are 18 prefixes for
integers: abcdefghi (for positive one to nine byte encodings, respectively), and
ABCDEFGHI (for negative one to nine byte encodings). Zero is encoded as the
digit '0'.

Floating point numbers are more straightforward to encode because two base-94
bytes (an entropy of 8836) is enough information to encode the exponent (entropy
of 308), exponent sign (entropy of 2), and mantissa sign (entropy of 2). The
remaining entropy of 7.17 is used to encode the number of bytes used to
represent the mantissa -- because the mantissa contains up to 53 bits, the
seven values map to 1, 2, 3, 4, 5, 7, and 9 bytes. The prefix for floating-point
numbers is 'j'.

Strings are escape-encoded and are prefixed by their length. This means that 84
characters map directly to themselves, and there are ten escape prefixes. The
first two escape prefixes each take one following base-94 character, thus
encoding a combined entropy of 188. This two-byte escape is used for character
codes between 0 and 255 inclusive (remember that we don't need to worry about 84
of those characters). The prefix for strings is '$'.

Unicode characters are encoded as three-byte escapes; there are eight prefixes
followed by two base-94 characters. (This has a total entropy of 70688, which is
sufficient to encode the 65280 remaining possibilities.)

The two-byte escape prefixes are ! and ", and the three-byte escape prefixes are
#, $, %, &, ', (, ), and *. This leaves a contiguous range of ASCII characters
between 43 and 126 inclusive; these are all encoded verbatim.

There are some special cases when encoding strings. Most strings that end up in
the constant table are actually quite short, so there are a bunch of prefixes
for strings that are small. They begin at the character K and continue until `,
which directly precedes 'a'. K denotes a string of length 1; the zero-length
string is implicitly present in the constant table.

String encoding is also used for regular expressions. The only difference here
is that there are several different regexp prefixes, one to encode each
configuration of flags. The prefixes and flag combinations are:

| r: /foo/      v: /foo/g
  s: /foo/i     w: /foo/gi
  t: /foo/m     x: /foo/gm
  u: /foo/mi    y: /foo/gmi

Nonstandard flags such as the 'y' in Firefox 3 are not serialized.

Dates are encoded in milliseconds since the epoch, which requires 7 base-94
characters. There is only one date prefix, 'J'.

Functions are encoded as strings but have different prefixes. Their properties
are referenced from the reference section, where they are treated as objects for
the purposes of edge connections (see 'Reference section' below). The function
prefix is '#'.

Some functions are used as constructors; these are modified at deserialization
time to make them safe to invoke. Not all functions need this modification,
though. Functions that are known constructors use the '@' prefix instead of '#'.

Arrays are encoded as the single character !. Their children are described in
the reference graph, since arrays can have circular references.

Regular objects (that is, those without a custom .constructor property) are
encoded by the single character ". If an object has a custom .constructor
property, it is encoded as a % followed by four bytes identifying the
constant-table index of its constructor function. This deserializer knows to
modify the constructor function in such a way that it can be safely invoked to
recreate the object. (The object's other properties are stored in the reference
graph.)

In addition to literal constants, the constant table encodes the number of
arrays and objects that exist. These are then referenced and made into a graph
in the reference section.


Reference section.
This section forms a graph from the objects in the constant table. It consists
first of a four-byte number to indicate how many objects are included, and then
a series of base-94 numbers, each one wide enough to address any constant. These
numbers form a series of edge descriptions. Each edge description looks like
this:

| <object index> <number of edges> <edge> <edge> ... <edge>

Each edge is a pair of constant table indexes; the first is a string or integer
to encode the slot, and the second is the value that the slot refers to. (So,
for example, {foo: 'bar'} would have one edge whose slot index points to the
string 'foo' and whose value index points to the string 'bar'.) The number of
edges is always four bytes wide.
